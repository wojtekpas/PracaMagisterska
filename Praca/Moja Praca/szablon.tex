\documentclass[twoside,a4paper]{book}

\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\DeclareMathOperator{\sign}{sign}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{array}
% pakiet stosowany do url'i w bibliografii, zamienia odnośniki na ładnie sformatowane
\usepackage{url}
% pakiety służące do numerowania i tworzenia algorytmów
\usepackage{algorithmic}
\usepackage{algorithm}
% redefinicja etykiety nagłówkowej listy algorytmów, domyślna jest po angielsku
\renewcommand{\listalgorithmname}{Spis algorytmów}

% pakiet do wyliczania skali, przydatny przy dużych obrazkach
\usepackage{pgf}
% pakiet służący do automatycznego sortowania odnośników do bibliografii
\usepackage[sort]{natbib}
% tworzenie listingów
\usepackage{listings}
% tworzenie figur wewnątrz figur
\usepackage{subfig}
% do automatycznego skracania nazw rozdziałów i podrozdziałów używanych w nagłówkach strony by mieściły się w jednej linii
\usepackage[fit]{truncate}
% fancyhdr - ładne nagłówki, definicja wyglądu nagłówka, numery stron będą umieszczane w nagłówku po odpowiedniej stronie
\usepackage{listings}
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{}
\fancyhead[LE,RO]{\bfseries\thepage}
% tutaj ograniczamy szerokość pola w nagłówku zawierającego nazwę rozdziału/podrozdziału do 95% szerokości strony
% redefinicja sposobu prezentacji nazw domyślnie wypisywanych wielkimi literami (np. domyślnie w nagłówku Spis treści będzie miał postać SPIS TREŚCI)
% Uwaga! to może popsuć wielkie litery w ogóle! Jak coś nie działa należy usunąć \nouppercase{} z poniższych definicji
\fancyhead[LO]{\nouppercase{\bfseries{\truncate{.95\headwidth}{\rightmark}}}}
\fancyhead[RE]{\nouppercase{\bfseries{\truncate{.95\headwidth}{\leftmark}}}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}

% definicja typu prostego wymagana przez pierwsze strony rozdziałów itp.
% powyższe reguły niestety tych stron nie dotyczą, gdyż Latex automatycznie przełącza je pomiędzy fancy a plain
% w tym wypadku eliminujemy nagłówki i stopki na stronach początkowych
\fancypagestyle{plain}{%
 \fancyhead{}
 \fancyfoot{}
 \renewcommand{\headrulewidth}{0pt}
 \renewcommand{\footrulewidth}{0pt}
}

\parskip 0.05in
\linespread{1.3}

% makro umożliwiające otaczanie symboli okręgami
\usepackage{tikz}
% brak justowania tekstu (bazą okręgu będzie linia tekstu)
\newcommand*\mycirc[1]{%
  \begin{tikzpicture}
    \node[draw,circle,inner sep=1pt] {#1};
  \end{tikzpicture}}

% pionowe justowanie tekstu, środek okręgu pokrywa się ze środkiem tekstu
\newcommand*\mycircalign[1]{%
  \begin{tikzpicture}[baseline=(C.base)]
    \node[draw,circle,inner sep=1pt](C) {#1};
  \end{tikzpicture}}

% zmiana nazwy twierdzeń i lematów
\newtheorem{theorem}{Twierdzenie}
\newtheorem{definition}{Definicja}
\newtheorem{example}{Przykład}

% tworzenie definicji dowodu
\newenvironment{proof}[1][Dowód]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% \newenvironment{definition}[1][Definicja]{\begin{trivlist}
% \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
% \newenvironment{example}[1][Przykład]{\begin{trivlist}
% \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Wniosek]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

% definicja czarnego prostokąta zwyczajowo dodawanego na koniec dowodu
\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}

% poniższymi instrukcjami można sterować co ma być numerowane a co nie i co ma być wyświetlane w spisie treści
% \setcounter{secnumdepth}{3}
% \setcounter{tocdepth}{5}

% definicja czcionki mniejszej niż tiny (domyślnie takiej małej nie ma)
\usepackage{lmodern}
\makeatletter
  \newcommand\tinyv{\@setfontsize\tinyv{4pt}{6}}
\makeatother

% definicja jeszcze mniejszej czcionki
\usepackage{lmodern}
\makeatletter
  \newcommand\tinyvv{\@setfontsize\tinyvv{3.5pt}{6}}
\makeatother

% pakiet do obsługi wieloicowych tabel
\usepackage{longtable}
\setlength{\LTcapwidth}{\textwidth}

\usepackage[section] {placeins}

\usepackage{multirow}

\usepackage{slantsc}

% nazwa pliku ze stroną tytułową
% \include{phd_titlepage}
\include{mgr_titlepage}

% parametry strony tytułowej, zdefiniowane są w plikach z poszczególnymi stronami
% tytuł pracy
\title{Obliczanie zer wielomianów}
% autor
\author{Wojciech Pasternak}
% rok wydania
\date{2016}
% miasto, gdzie napisano pracę
\miasto{Gdańsk}
% promotor
\promotor{dr hab. inż. Robert Janczewski}
% wydział promotora, tylko dla phd_titlepage
% \promotordpt{Wydział Elektroniki, Telekomunikacji i~Informatyki}
% uczelnia promotora, tylko dla phd_titlepage
% \promotoruniv{Politechnika Gdańska}

% rodzaj studiów, tylko dla mgr_titlepage
\studies{Stacjonarne jednolite studia magisterskie}
% opis pracy, tylko dla mgr_titlepage
\descr{Obliczanie pierwiastków wielomianów i porównanie służących do tego struktur}
% nr indeksu, tylko dla mgr_titlepage
\indeks{137361}
% katedra, tylko dla mgr_titlepage
\dept{Architektury Systemów Komputerowych}

% korekta marginesów - domyślnie latex ma jakieś kosmiczne
\usepackage{anysize}
\marginsize{3.5cm}{2.5cm}{2.5cm}{2.5cm}
% po zmianie marginesów konieczne jest wymuszenie przeliczenia nagłówków
\fancyhfoffset[E,O]{0pt}

\begin{document}
% sekcja wstępna książki, numerowana rzymskimi
\frontmatter
% generacja strony tytułowej załączonej wcześniej
\maketitle
% spis treści
\tableofcontents

% właściwa część książki, numerowana arabskimi od 1
\mainmatter

\chapter{Wstęp}
\chapter{Przegląd literatury}
\section{Wielomiany}
\subsection{Definicja}

\begin{definition}
	Wielomianem zmiennej rzeczywistej x nazywamy wyrażenie:
	\begin{equation}
		\begin{split}
			&W(x) = a_0x^n + a_1x^{n-1} + a_2x^{n-2}+ ... + a_{n-1}x + a_n, \\
			&gdzie\ a_0, a_1, a_2, ..., a_{n-1}, a_n\in R, n \in N 
		\end{split}
	\end{equation}
\end{definition}

Liczby $a_0, a_1, a_2, ..., 1_{n-1}, a_n$ nazywamy współczynnikami wielomianu, natomiast n nazywamy stopniem wielomianu.
	
Szczególnym przypadkiem wielomianu jest jednomian. 

\begin{definition}
	Jednomianem zmiennej rzeczywistej x nazywamy wielomian, który posiada co najwyżej jeden wyraz niezerowy i określamy wzorem:
	\begin{equation}
		\begin{split}
			W(x) = ax^n, gdzie\ a\in R, n \in N 
		\end{split}
	\end{equation}
\end{definition}

Można, więc rozumieć wielomian jako skończoną sumę jednomianów.
Jednomianem stopnia zerowego jest stała, pojedyncza liczba rzeczywista, która w szczególności może być zerem.

\begin{definition}
	Wielomianem zerowym nazywamy, wielomian wyrażony wzorem:
	\begin{equation}
		W(x) = 0
	\end{equation}
\end{definition}

W dalszej części, jeżeli nie zaznaczymy inaczej, mówiąc wielomian, będziemy mieli na myśli pewien wielomian, nie będący wielomianem zerowym.

\subsection{Podstawowe działania na wielomianach}

Na wielomianach, tak jak na liczbach możemy wykonywać podstawowe działania. Należą do nich: porównywanie, dodawanie, odejmowanie, mnożenie, dzielenie, a także obliczanie reszty z dzielenia oraz NWD (największego wspólnego dzielnika). Jako, że wielomian zmiennej x możemy traktować jak funkcję jednej zmiennej, możemy także policzyć z niego pochodne.

\subsubsection{Porównywanie wielomianów}

Porównywanie należy do najbardziej elementarnych działań na wielomianach. Wymaga ono zwykłego porównania kolejnych współczynników, a jego długość trwania, zależy od ich liczby. Zapoznajmy się z twierdzeniem dotyczącym operacji porównywania wielomianów.

\begin{theorem}
	Dwa wielomiany uważamy za równe wtedy i tylko wtedy, gdy są tego samego stopnia, a ich kolejne współczynniki są równe.
\end{theorem}

Powyższe twierdzenie nie jest złożone, nie mniej w celu pełnego zrozumienia, zilustrujmy je przykładem. 

\begin{example}
	Mamy dane wielomian $W_1$ oraz wielomian $W_2$.
	\begin{equation}
		\begin{split}
			&W_1(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n \\
			&W_2(x) = b_0x^n + b_1x^{n-1} + ... + b_{n-1}x + b_n \\
		\end{split}
	\end{equation}
	Wielomiany $W_1$ oraz $W_2 $ są równe wtedy i tylko wtedy gdy
	$\forall{i\in N}\ a_i = b_i$.
\end{example}

Można zauwazyć, potencalny wpływ reprezentacji wielomianu na szybkość operacji porównania. Gdy mamy do czynienia z wielomianem, w którym uwzględniamy każdy współczynnik, także gdy jest on zerowy, złożoność czasowa porównania jest liniowa względem stopnia wielomianu. Natomiast w przypadku, gdy pomijamy wszystkie zerowe współczynniki wielomianu, złożoność również jest liniowa, ale tym razem względem liczby niezerowych współczynników wielomianów. Jak widać, w sytuacji, gdy stopień wielomianu jest znacznie większy od liczby zerowych współczynników, reprezentacja wielomianu ma niebagatelne znaczenie. \newline
Dodatkowo, podobnie jak w przypadku porównywania liczb i sprawdzania kolejnych bitów, operacja porównania kończy się w momencie stwierdzenie, że porównywane współczynniki są różne lub porównaliśmy ze sobą już wszystkie współczynniki. Wynika z tego, że zakładając stały czas porównywania dwóch liczb, będącymi współczynnikami wielomianów, operacja porównania różnych wielomianów nigdy nie jest dłuższa od stwierdzenia, że porównywane wielomiany są równe.

\subsubsection{Suma wielomianów}

Dodawanie to kolejne elementarne działanie na wielomianach, które nie wymaga wykonywania skomplikowanych obliczeń.

\begin{theorem}
	Aby dodać dwa wielomiany, należy dodać ich wyrazy podobne.
\end{theorem}

Podobnie jak w przypadku porównywania czas dodawania wielomianów jest liniony, a ich reprezentacja ma zasadniczy wpływ na liczbę operacji dodawania. Pokażmy zastosowanie powyższego twierdzenia na przykładzie.

\begin{example}
	Mamy dane wielomian $W_1$ oraz wielomian $W_2$.
	\begin{equation}
		\begin{split}
			&W_1(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n \\
			&W_2(x) = b_0x^n + b_1x^{n-1} + ... + b_{n-1}x + b_n \\
		\end{split}
	\end{equation}
	Zdefiniujmy trzeci wielomian: $W_3(x) = W_1(x) + W_2(x)$. Wówczas:
	\begin{equation}
		W_3(x) = (a_0+b_0)x^n + (a_1+b_1)x^{n-1} + ... + (a_{n-1} + b_{n-1})x + a_n + b_n
	\end{equation}
\end{example}

Na powyższym przykładzie łatwo zaobserwować, że stopień sumy dwóch wielomianów nie może być większy od większego ze stopni dodawanych wielomianów. Znajduje to potwierdzenie w twierdzeniu, dotyczącym stopnia sumy wielomianów.

\begin{theorem}
	\begin{equation}
		\deg(W_1 + W_2) \le max(deg(W_1),\ deg (W_2))
	\end{equation}
\end{theorem}

W przedstawionym twierdzeniu, należy uwagę na operator mniejsze równe. W przypadku gdy oba te wielomiany są tego samego stopnia, o przeciwnym współczynniku przy najwyższej potędze, to stopień ten będzie mniejszy.

\subsubsection{Różnica wielomianów}

Odejmowanie to operacja bliźniacza do dodowania, nie tylko w przypadku liczb, ale także w przypadku wielomianów. By pokazać olbrzymie podobieństwo tych operacji, zacznijmy od zapoznania się z definicją wielomianu przeciwnego.

\begin{definition}
	Wielomianem przeciwnym nazywamy wielomian, którego wszystkie współczynniki są przeciwne do danych.
\end{definition}

Spójrzmy na poniższy przykład, pokazujący, że dla każdego wielomianu można bardzo prosto zdefiniować wielomian przeciwny, zmieniając znak wszystkich jego współczynników.

\begin{example}
	Mamy dany wielomian $W_1$.
	\begin{equation}
		W_1(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n
	\end{equation}
	Zdefiniujmy drugi wielomian: $W_2(x) = -W_1(x)$. Wówczas:
	\begin{equation}
		W_1(x) = -a_0x^n + (-a_1)x^{n-1} + ... + (-a_{n-1})x + (-a_n)
	\end{equation}
\end{example}

Wiemy już, czym jest wielomian przeciwny. Przedstawmy teraz twierdzenie mówiące jak odejmować od siebie wielomiany.

\begin{theorem}
	Aby obliczyć różnicę wielomianów $W_1$ i $W_2$, należy dodać ze sobą wielomiany $W_1$ i $-W_2$, czyli wielomian przeciwny do wielomianu $W_2$.
\end{theorem}

Jak widać, przedstawione twierdzenie potwierdza analogię obliczania róznicy i sumy wielomianów. Spójrzmy na przykład, pokazujący jak obliczać różnicę wielomianów, potrafiając już je do siebie dodawać.

\begin{example}
	Mamy dane wielomian $W_1$ oraz wielomian $W_2$.
	\begin{equation}
	\begin{split}
	&W_1(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n \\
	&W_2(x) = b_0x^n + b_1x^{n-1} + ... + b_{n-1}x + b_n \\
	\end{split}
	\end{equation}
	Zdefiniujmy trzeci wielomian: $W_3(x) = W_1(x) - W_2(x)$. Wówczas:
	\begin{equation}
		W_3(x) = (a_0-b_0)x^n + (a_1-b_1)x^{n-1} + ... + (a_{n-1} - b_{n-1})x + a_n - b_n
	\end{equation}
\end{example}

Warto zauważyć, że wielomianem neutralnym ze względu na dodawanie i odejmowanie jest wielomian $W(x)=0$. Oznacza to, że po dodaniu lub odjęciu wielomianu neutralnego, dostaniemy wynik, będący danym wielomianem.

\subsubsection{Iloczyn wielomianów}

Mnożenie to kolejne operacja zaliczająca się do podstawowych działań na wielomianach. Jego zasady przypominają nieco zwykłe mnożenie. Dokonujemy przemnożenia odpowiednich wyrazów, z tą różnicą, że w tym przypadku po prostu dodajemy wartości potęg dla odpowiednich współczynników. Zapoznajmy się z twierdzeniem, mówiącym dokładnie jak należy obliczać iloczyn wielomianów.

\begin{theorem}
	Aby pomnożyć dwa wielomiany, należy wymnożyć przez siebie wyrazy obu wielomianów, a następnie dodać do siebie wyrazy podobne.
\end{theorem}

Jak wynika z przedstawionej definicji poza mnożeniem dwóch liczb, mnożenie wielomianów w części polega na redukcji wyrazów podobnych, czyli operacji bazującej na dodawaniu. Spójrzmy na przykład, pokazujący jak definiuje się wielomian, będacy iloczynem dwóch wielomianów.

\begin{example}
	Mamy dane wielomian $W_1$ oraz wielomian $W_2$.
	\begin{equation}
	\begin{split}
	&W_1(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n \\
	&W_2(x) = b_0x^m + b_1x^{m-1} + ... + b_{m-1}x + b_m \\
	\end{split}
	\end{equation}
	Zdefiniujmy trzeci wielomian: $W_3(x) = W_1(x) * W_2(x)$. Wówczas:
	\begin{equation}
		\begin{split}
		W_3(x) = &(a_0b_0)x^{n+m} + (a_0b_1+a_1b_0)x^{n+m-1} + (a_0b_2+a_1b_1+a_2b_0)x^{b+m-1} + ... \\
		&+ (a_{n-2}b_m+a_{n-1}b_{m-1}+a_nb_m)x^2 + (a_{n-1}b_m + a_nb_{m-1})x + a_nb_m \\
		\end{split}
	\end{equation}
\end{example}

Można zauważyć, że po wymnożeniu wszystkich współczynników wielomianu liczba wyrazów iloczynu wynosi $(n+1)(m+1)$. Po dokonaniu redukcji wyrazów podobnych liczba ta ulega zmniejszeniu do wartości $n+m+2$. Oznacza to zmianę liczby wyrazów z wartości kwadratowej, do wartości liniowej względem stopni wielomianów. Liczba wyrazów podobnych, po przemnożeniu dwóch wielomianów jest symetryczna względem wykładników potęg poszczególnych współczynników. Można zauważyć, że skrajne wyrazy posiadają tylko po jednym wyrazie potęgi, a zbliżając się do współczynników o środkowych indeksach, liczba ta wzrasta, aż do wartości równej połowie stopnia otrzymanego wielomianu. \newline

Widzimy, że czas operacji mnożenia wielomianów jest kwadratowy, wzgędem stopni mnożonych przez siebie czynników. Należy zauważyć, że jeżeli użyjemy reprezentacji wielomianu, w których posiadamy informację tylko o jego niezerowych współczynników, to czas operacji mnożenie będzie nadal kwadratowy, jednak względem liczby tych współczynników. Dla wielomianów wysokich stopni, w których zaledwie kilka współczynników jest niezerowych różnica ta może być niegatelna i w skrajnych przypadkach czas operacji może zmniejszyć się z kwadratowego, do czasu stałego.

Na podstawie powyższego przykładu, możemy także zaobserwować, że stopień wielomianu, będącego iloczynem dwóch wielomianów niezerowych, jest standardowo równy sumie stopni tych wielomianów. Wyjątkiem jest sytuacja gdy jeden z czynników jest wielomianem zerowym. Wówczas wynik takiej operacji również będzie wielomianem zerowym. Fakt ten znajduje potwierdzenie w poniższym twierdzeniu.

\begin{theorem}
	\begin{equation}
	\begin{split}
	&deg(W_1 * W_2) = deg(W_1) + deg(W_2),\ dla\ W_1(x) != 0, W_2(x) != 0 \\
	&W_3(x) = W_1(x) * W_2(x) = 0,\ w \ pozostałych\ przypadkach
	\end{split}
	\end{equation}
\end{theorem}

Z powyższego twierdzenia można zauważyć, że stopień otrzymanego wielomianu nigdy nie będzie wyższy od dwukrotności większego ze stopni mnożonych wielomianów.

\subsubsection{Iloraz wielomianów}

Dzielenie to zdecydowanie najtrudniejsza z elementarnych operacji na wielomianach. Aby dobrze zrozumieć jego zasady zapoznajmy się z definicją podzielności wielomianów oraz dzielnika wielomianu.

\begin{definition}
	Wielomian W(x) nazywamy podzielnym przez niezerowy wielomian P(x) wtedy i tylko wtedy, gdy istnieje taki wielomian Q(x), że spełniony jest warunek $W(x) = P(x) * Q(x)$. Wówczas: wielomian Q(x) nazywamy ilorazem wielomianu W(x) przez P(x), zaś wielomian P(x) nazywamy dzielnikiem wielomianu W(x).
\end{definition}

Bardzo ważnym aspektem obliczania ilorazu wielomianów jest reszta z dzielenia. Spójrzmy na poniższą definicję.

\begin{definition}
	Wielomian R(x) nazywamy resztą z dzielenia wielomianu W(x) przez niezerowy wielomian P(x) wtedy i tylko wtedy, gdy istnieje taki wielomian Q(x), że spełniony jest warunek $W(x) = P(x) * Q(x) + R(x)$.
\end{definition}

Łatwo zauważyć analogię w wyżej przedstawionych wzorach. Różnią się one właśnie wielomianem $R(x)$, czyli resztą z dzielenia. Gdy jest ona wielomianem zerowym, to znaczy, że mamy do czynienia z dzieleniem bez reszty i mówimy o podzielności dwóch wielomianów. Spórzmy na przykład, w którym zdefiniowane zostały dwa wielomiany, będące ilorazem i resztą z dzielenia dwóch wielomianów.

\begin{example}
	Mamy dane wielomian W oraz wielomian P.
	\begin{equation}
		\begin{split}
			&W(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n \\
			&P(x) = b_0x^m + b_1x^{m-1} + ... + b_{m-1}x + b_m \\
		\end{split}
	\end{equation}
	Zdefiniujmy wielomian: $Q(x) = \frac{W(x)}{P(x)}$ oraz $Q(x) = W(x)\ mod\ P(x)$. Wówczas:
	\begin{equation}
		\begin{split}
			&Q(x) = c_0x^{n-m} + c_1x^{n-m-1} + ... + c_{n-m-1}x + c_{n-m},\ gdzie\ c_0\ne 0 \\
			&R(x) = d_0x^{n-m-1} + d_1x^{n-m-2} + ... + d_{n-m-2}x + d_{n-m-1} \\
		\end{split}
	\end{equation}
\end{example}

Zwróćmy uwagę na potęgi stojące przy najwyższych potęgach wielomianów $Q(x)$ oraz $R(x)$. Widzimy, że stopień ilorazu wielomianów jest zawsze równy różnicy stopni wielomianów, będących dzielną i dzielnikiem. Najważniejszym aspektem jest jednak fakt, że stopień reszty z dzielenia wielomianów jest zawsze mniejszy od stopnia ilorazu. Nie można natomiast ustalić jego wartości, bez dokładnej znajomości wielomianów W i P. W przykładzie podkreślony został fakt, że współczynnik stojący przy x, o potędze $n-m-1$ może być zerem. To samo tyczy się także kolejnych współczynników. Gdy wszystkie one są zerami, to znaczy, że mamy do czynienia z resztą, będąco wielomianem zerowym. Oznacza to wówczas, że wielomian W jest podzielny przez wielomian P. Poniżej znajduje się twierdzenie, o stopniach wielomianów, będących ilorazem i resztą z dzielenia.

\begin{theorem}
	\begin{equation}
	deg(W_1\ mod\ W_2) < deg(W_1 / W_2) = deg(W_1) - deg(W_2)
	\end{equation}
\end{theorem}

Jak widać, twierdzenie potwierdza nasze obserwacje i wnioski dotyczące stopni obu wielomianów.


\subsubsection{Pochodna wielomianu}

Wielomiany jako przykład funkcji ciągłej, pozwalają na obliczanie pochodnych. By przekonać się, że jest to przykład jednej z prostszych operacji na wielomianach, zapoznajmy się z definicją.

\begin{definition}
	Dany jest wielomian W, określony wzorem $W(x) = a_0x^n + a_1x^{n-1} + ... + a_{n-1}x + a_n$. Pochodną wielomianu W nazywamy wielomian W' i wyrażamy wzorem:
	\begin{equation}
	W(x) = na_0x^{n-1} + (n-1)a_1x^{n-2} + ... + 2a_{n-2}x + a_{n-1}
	\end{equation}
\end{definition}

Widzimy, że powstały wielomian powstał poprzez pomnożenie wartości każdego z współczynników przez stojącą przy danym wyrazie potęgę, a następnie obniżenie jej wartości o jeden. W ten sposób potęgi wszystkich wyrazów wielomianu obniżają się. Wyjątkiem jest tutaj potęga o wartości zero, czyli stała. Pochodna z funkcji stałej jest zawsze równa zero, dlatego została pominięta w powyższym wzorze. O stopniu pochodnej wielomianu mówi poniższe twierdzenie.

\begin{theorem}
	\begin{equation}
	\begin{split}
		&deg(W') = deg(W) - 1,\ dla\ deg(W) > 0 \\
		&W(x) = 0,\ w\ pozostałych\ przypadkach
	\end{split}
	\end{equation}
\end{theorem}

Jak widać dla wszystkich wielomianów, nie będących stałą liczbową, stopień ich pochodnej ulega zmniejszeniu o jeden. Czas operacji obliczania pochodnej wielomianu jest porównywalny, z obliczaniem sumy wielomianów, gdyż wystarczy, że dokonamy jednokrotnego obliczania każdego z współczynników.

%\subsubsection{NWD wielomianów}

\subsection{Dodatkowe twierdzenia dotyczące wielomianów}

Istnieje mnóstwo twierdzień dotyczących wielomianów. Zapoznajmy się z tymi, które ułatwią nam znajdowanie pierwiastków wielomianów. Zapoznajmy się z pierwszym twierdzeniem, mówiącym o możliwości zamienienia dowolnego wielomianu o współczynnikach wymiernych, w wielomian o współczynnikach całkowitych.

\begin{theorem}
	Dowolny wielomian $W_1(x) = \frac{a_n}{b_n}x^n + \frac{a_{n-1}}{b_{n-1}}x^{n-1} + ... + \frac{a_1}{b_1}x + \frac{a_0}{b_0}$, o współczynnikach wymiernych, można przekształcić w wielomian $W_2(x) = k * W_1(x)$, o współczynnikach całkowitych i tych samych pierwiastkach, co wielomian W. Wówczas:
	\begin{equation}
	k = m * NWW(b_0, b_1, ..., b_{n-1}, b_n),\ gdzie\ m\in Z
	\end{equation}
\end{theorem}

Twierdzenie to oznacza, że przy dysponując wyłącznie współczynnikami, będącymi liczbami całkowitymi, jesteśmy w stanie przedstawić dowolny wielomian o współczynnikach wymiernych. Przejdźmy teraz do twierdzenia, mówiącego o wartości wielomianu w danym punkcie.

\begin{theorem}
	Jeżeli wielomian W(x) podzelimy przez dwumian $x - x_0$, to reszta z tego dzielenia jest równa wartości tego wielomianu dla $x = x_0$.
\end{theorem}

W szczególnym przypadku reszta ta może być równa zero. Oznacza to, że liczba $x_0$ jest pierwiastkiem tego wielomianu. Wynika z tego bezpośrednio kolejne twierdzenie, znane jako twierdzenie Bezout.

\begin{theorem}[Bezout]
	Liczba $x_0$ jest pierwiastkiem wielomianu W(x) wtedy i tylko wtedy, gdy wielomian jest podzielny przez dwumian $x - x_0$.
\end{theorem}

Dodatkowo zapoznajmy się jeszcze z krótkim dowodem poprawności powyższego twierdzenia.

\begin{proof}
	Jeżeli liczba $x_0$ jest pierwiastkiem wielomianu W, to wielomian ten możemy wyrazić jako iloczyn dwumianu $x - x_0$ oraz pewnego wielomianu Q: $W(x) = (x-x_0) * Q(x)$. Wyznaczając z tego wyrażenia wielomian Q, otrzymujemy $Q(x) = \frac{W(x)}{x-x_0}$. Widzimy zatem, że dzieląc wielomian W(x) przez dwumian $x-x_0$, otrzymujemy bez reszty, wielomian Q(x).
\end{proof}

Przejdźmy teraz, to twierdzenia mówiącego o pierwiastkach wielokrotnych, bazującego na twierdzeniu Bezout.

\begin{theorem}
	Liczba $x_0$ jest pierwiastkiem k-krotnym wielomianu W(x) wtedy i tylko wtedy, gdy wielomian jest podzielny przez $(x - x_0)^k$ i nie jest podzielny przez $(x - x_0)^{k+1}$.
\end{theorem}

Dowód poprawności jest analogiczny, jak dla twierdzenia Bezout. Jedyną różnicą jest to, że wielomian W przedstawiamy jako: $W(x) = (x-x_0)^k * Q(x)$. Zapoznajmy się z twierdzeniem, mówiących o możliwej wartości pierwiastków, o ile są one całkowite.

\begin{theorem}
	Dany jest wielomian $W(x) = x^n + a_{n-1}x^{n-1} + ... + a_1x + a_0$, o współczynnikach całkowitych. Jeżeli wielomian W posiada pierwiastki całkowite, to są one dzielnikami wyrazu wolnego $a_0$.
\end{theorem}

Przejdźmy teraz do twierdzeń mówiących o możliwości rozłożenia wielomianu na czynniki.

\begin{theorem}
	Każdy wielomian W(x) nie będący wielomianem zerowym jest iloczynem czynników stopnia co najwyżej drugiego.
\end{theorem}

Oznacza to, że każdy wielomian stopnia co najmniej trzeciego jest rozkładalny na czynniki. Z powyższego twierdzenia wynika kolejne, mówiące, że rozkład ten jest zawsze jednoznaczny.

\begin{theorem}
	Niezerowy wielomian, o współczynnikach rzeczywistych, jest jednoznacznie rozkładalny na czynniki liniowe lub nierozkładalne czynniki kwadratowe, o współczynnikach rzeczywistych.
\end{theorem}

Oznacza to, że nie da się rozłożyć jednego wielomianu na czynniki, na dwa różne sposoby, tzn. tak, by istniał chociaż jeden czynnik (lub jego proporcjonalny odpowiednik), nie występujący w drugim rozkładzie. Ważnym aspektem, wynikającym z powyższego twierdzenia jest mowa, o tym że nie wszystkie wielomiany da się rozłożyć na czynniki liniowe, o współczynnikach całkowitych. Spójrzmy na pokazujący to przykład.

\begin{example}
	Mamy dany wielomian $W(x)=x^3-1$. Rózłóżmy go na czynniki.
	Wiemy, że pierwiastkiem tego wielomianu jest $x_0 = 1$, zatem możemy przedstawić wielomian W jako iloczyn wielomianu $x-1$ oraz drugiego wielomianu.
	\begin{equation}
	\begin{split}
	W(x)=&x^3-1=x^3-x^2+x^2-x+x-1=(x-1)x^2+(x-1)x+x-1 = \\
	&=(x-1)(x2+x+1) \\
	&\Delta = 1^2 - 4*1*1 = 1 - 4 = -3 < 0 - brak\ pierwiastków\ rzeczywistych\\
	\end{split}
	\end{equation}
	Jak widać drugi z czynników jest właśnie przykładem nierozkładalnego czynnika kwadratowego, o współczynnikach rzeczywistych.
\end{example}

Powyższy czynnik da się rozłożyć na dwa czynniki liniowe, o współczynnikach zespolonych. W pracy tej będziemy jednak mówić wyłącznie o współczynnikach rzeczywistych, najczęściej zawężając jeszcze zbiór potencjalnych współczynników, do liczb wymiernych. Przejdźmy do kolejnego twierdzenia, wynikającego bezpośrednio z dwóch poprzednich.

\begin{theorem}
	Każdy wielomian stopnia nieparzystego, ma przynajmniej jeden pierwiastek rzeczywisty.
\end{theorem}

Oznacza to, że każdy wielomian stopnia nieparzystego jesteśmy w stanie przedstawić jako iloczyn dwóch czynników, z których jeden jest czynnikiem liniowym, a drugi czynnikiem stopnia parzystego, który z kolei być może da się dalej rozłożyć, na wielomiany, o mniejszych stopniach.

\section{Eliminacja pierwiastków wielokrotnych}

Ważnym aspektem obliczanie zer wielomianów jest eliminacja pierwiastków wielokrotnych. Jest ona niezbędna, by móc skorzystać z metody Sturmy. Zapoznajmy się z twierdzeniem dotyczącym krotności pierwiastków pochodnej wielomianu.

\begin{theorem}
	Jeżeli liczba jest pierwiastkiem k-krotnym wielomianu W, to jest pierwiastkiem (k-1)-krotnym pochodnej tego wielomianu.
\end{theorem}

By lepiej zrozumieć twierdzenie, spójrzmy na poniższy przykład.

\begin{example}
	Mamy dany wielomian $W(x) = x^3 + 2x^2 + x$. Obliczmy teraz kolejne pochodne wielomianu W.
	\begin{equation}
	\begin{split}
	&W'(x) = 3x^2 + 2*2x + 1 = 3x^2 + 4x + 1 \\
	&W^{(2)}(x) = 2*3x + 4 = 6x + 4 \\
	&W^{(3)}(x) = 6
	\end{split}
	\end{equation}
	Obliczmy teraz pierwiastki wielomianu W i jego kolejnych pochodnych.
	\begin{equation}
	\begin{split}
	&W(x) = x^3 + 2x^2 + x = x(x^2 + 2x +1) = x(x + 1)^2 \\
	&x_1 = 0,\ k_1 = 1,\ x_2 = -1,\ k_2 = 2 \\
	&W'(x) = 3x^2 + 4x + 1 \\
	&\Delta = 4^2 - 4*3*1 = 16 - 12 = 4 \\
	&\sqrt{\Delta} = 2 \\
	&x_1 = \frac{-4-2}{2*3} = \frac{-6}{6} = -1,\ k_1 = 1,\ x_2 = \frac{-4+2}{2*3} = \frac{-2}{6} = -\frac{1}{3},\ k_2 = 1 \\
	&W^{(2)}(x) = 6x + 4 = 6 (x + \frac{2}{3}) \\
	&x_1 = -\frac{2}{3},\ k_1 = 1 \\
	&W^{(3)}(x) = 6\ -\ brak\ pierwiastków \\
	\end{split}
	\end{equation}
\end{example}

Jak widać powyższy przykład potwierdza zastosowanie przedstawionego twierdzenia. Widzimy, że krotność wszystkich pierwiastków ulega zmniejszeniu o jeden, w kolejnej pochodnej. Dodatkowo możemy zauwazyć, że pochodna może zawierać także pierwiastki, których nie miał dany wielomian. Ma to miejsce w przypadku, gdy wielomian, posiada przynajmniej dwa różne pierwiastki. Potwierdza to poniższe twierdzenie.

\begin{theorem}
	Liczba nowych pierwiastków pochodnej wielomianu W' (takich których nie posiadał wielomian W) jest równa liczbie różnych pierwiastków wielomianu pomniejszonej o jeden.
\end{theorem}

By dowieść powyższego twierdzenia przeprowadźmy rozumowanie dowodzące jego poprawności.

\begin{proof}
	Zdefiniujmy wielomian: $W(x)=(x-x_1)^{k_1}*(x-x_2)^{k_2}*...*(x-x_{m-1})^{k_{m-1}}*(x-x_m)^{k_m}$. Przyjmijmy, że wielomian W jest stopnia n i posiada m różnych pierwiastków, gdzie $1\le m\le n,\ k_1+k_2+...+k_{m-1}+k_m=n$. Zdefiniujmy wielomian $P(x)=(x-x_1)*(x-x_2)*...*(x-x_{m-1})*(x-x_m)$, w którym każdy z pierwiastków wielomianu W występuję dokładnie jeden raz. Pierwiastków jest m, zatem wielomian P jest stopnia m. Dzieląc wielomian W przez wielomian P, otrzymujemy bez reszty wielomian $Q(x)=(x-x_1)^{k_1-1}*(x-x_2)^{k_2-1}*...*(x-x_{m-1})^{k_{m-1}-1}*(x-x_m)^{k_m-1}$, który posiada każdy z pierwiastków wielomianu W, krotności pomniejszonej o jeden. Skoro krotność każdego z m pierwiastków uległa zmniejszeniu o jeden, to stopień wielomianu Q w stosunku do wielomianu W zmniejszył się o m. Stopień wielomianu Q jest wieć równy n-m.
	Na mocy twierdzenia wiemy także, że wielomian Q(x) jest podzielny również przez wielomian W', stopnia n-1. Zatem wielomian W' możemy przedstawić jako iloczyn wielomianu Q oraz innego wielomianu: $W'(x)=Q(x)*V(x)$. Wielomian V, zawiera wszystkie pierwiastki W', których nie posiadał wielomian W. Łatwo policzyć, że stopień wielomianu V jest równy: $\deg(V)=deg(W')-deg(Q)=(n-1)-(n-m)=n-1-n+m=m-1$. Jak widać, właśnie udowodniliśmy, że stopień ten jest równy liczbie różnych pierwiastków wielomianu W pomniejszonej o jeden.
\end{proof}

Spróbujmy teraz skorzystać z przedstawionego twierdzenia w przykładzie dokonującym eliminacji pierwiastków wielokrotnych.

\begin{example}
	Dany jest wielomian W, określony wzorem: $W(x)=x^6-6x^4-4x^3+9x^2+12x+4$. Dokonajmy eliminacji pierwiastków wielokrotnych dla wielomianu W. \\
	Obliczamy pochodną wielomianu.
	\begin{equation}
	\begin{split}
	&W'(x)=6*x^5-4*6x^3-3*4x^2+2*9x+12=\\
	&=6x^5-24x^3-12x^2+18x+12=6(x^5-4x^3-2x^2+3x+2)\\
	\end{split}
	\end{equation}
	Obliczmy teraz resztę z dzielenia wielomianu W przez wielomian W'.
	\begin{equation}
	\begin{split}
	&x\\\hline
	&x^6-6x^4-4x^3+9x^2+12x+4 : (x^5-4x^3-2x^2+3x+2) \\
	&-x^6+4x^4+2x^3-3x^2-2x \\\hline
	&-2x^4-2x^3+6x^2+10x \\
	\end{split}
	\end{equation}
	Kluczowa jest wartość reszty z dzielenia. Gdyby otrzymana reszta z dzielenia była wielomianem zerowym, to pochodna wielomianu było równocześnie NWD(W, W'). W tym przypadku tak jednak nie jest, więc wykonujemy analogiczną operację z tą różnicą, że nową dzielną jest dotychczasowy dzielnik, a reszta z wielomianu jest nowym dzielnikiem. Tę operację wykonujemy tak długo, jak otrzymana reszta jest niezerowego stopnia. W przypadku gdy jest ona jednocześnie wielomianem zerowym, to podobnie jak wyżej, aktualny dzielnik, jest naszym NWD(W, W'). W przypadku gdy otrzymana reszta jest niezerowym wielomianem stopnia zerowego, to największym wspólnym dzielnikiem wielomianów jest pewna niezerowa stała.
\end{example}

\section{Twierdzenie Sturma}

Przeanalizujmy na początek sposób konstruowania ciągu Sturma dla wielomianu W. Pierwszym wyrazem ciagu jest sam wielomian W. Z kolei drugim wyrazem jest pochodna wielomianu W. Kolejne wyrazy ciągu Sturma wyznaczamy obliczając resztę z ilorazu dwóch poprzednich wyrazów. Dzieje się to do uzyskania pierwszej reszty wielomianu, będącą wielomianem stopnia zerowego. Za każdym razem dzieląc wielomian stopnia n, przez wielomian stopnia m, gdzie $m<n$, mamy gwarancję, że wielomian będacy resztą tego ilorazu będzie stopnia mniejszego niż m. Korzystając z tego faktu, wiemy, że liczba wyrazów ciągu Sturma dla wielomianu W jest niewiększa od $\deg(W)+1$.

\begin{definition}
	Ciągiem Sturma dla wielomianu W nazywamy ciąg wielomianów: $X_0, X_1, X_2,...,$, takich że $X_0=W$, $X_1=W'$, a kolejne wyrazy definiuje się jako wielomian przeciwny to reszty z dzielenia dwóch poprzednich wyrazów, przy czym ostatnim wyrazem ciągu Sturma jest pierwszy wielomian stopnia zerowego. 
\end{definition}

Wiemy już jak definiować ciąg Sturma. Przeanalizujmy teraz jaki wpływ ma uzyskany ciąg Sturma na obliczanie pierwiastków wielomianu. By to zrobić, zapoznajmy się z kolejną definicją, mówiącą o liczbie zmian znaków ciagu Sturma.

\begin{definition}
	Liczbą zmian znaków ciągu Sturma dla wielomianu W(x) w punkcie x, obliczamy zliczając liczbę zmian pomiędzy kolejnymi wyrazami, pomijac te o wartości równej zero w punkcie x. Liczbę zmian znaku w punkcie $x=x0$ definiujemy jako wartość funkcji $Z(x_0)$.
\end{definition}

Wiemy już jak obliczać liczbę zmian ciagu Sturma. Sprawdźmy zatem, jak przekłada się ona na liczbę pierwiastków w danym przedziale.

\begin{theorem}
	Jeżeli wielomian W(x) nie ma pierwiastków wielokrotnych, to liczba pierwiastków rzeczywistych w przedziale $a<x\le y)$, jest równa $Z(a) - Z(b)$.
\end{theorem}

W ogólności twierdzenie Sturma można zastosować dla przedziału $(-\infty,+\infty)$, dopuszczając w ciągu Sturma wartości niewłaściwe $+\infty$ oraz $-\infty$. Wówczas $Z(-\infty)$ będzie oznaczać liczbę zmian znaków w ciągu $W(-\infty), W_1(-\infty), W_2(-\infty),..., W_m(-\infty)$, zaś $Z(+\infty)$ liczbę zmian w ciągu $W(+\infty), W_1(+\infty), W_2(+\infty),..., W_m(+\infty)$.

\begin{theorem}
	Liczba różnych pierwiastków rzeczywistych wielomianu W(x) jest równa $Z(-\infty)-Z(+\infty)$.
\end{theorem}

Stosując twierdzenie Sturma dla coraz mniejszych przedziałów możliwe jest wyznaczenie pierwiastków wielomianu z dowolną dokładnością. Sposób ten określony jest mianem metody Sturma.
Twierdzenie Sturma jest bardzo mocnym środkowiem używanym do znajdowania pierwiastków w określonym przedziale. Może być używana nie tylko dla wielomianów, ale dowolnej różniczkowalnej funkcji ciągłej. Zapoznajmy się z twierdzeniem, mówiącym o ograniczeniach dotyczących maksymalnej liczby zmian znaków dla Ciąg Sturma.

\begin{theorem}
	Liczba zmian znaków ciągu Sturma dla wielomianu W(x) jest mniejsza od liczby wyrazów tego ciągu i niewiększa od stopnia wielomianu W(x).
\end{theorem}

Można, więc zauważyć, że warunkiem wystarczającym i jednocześnie koniecznym do tego by wielomian W(x) stopnia n, posiadający wyłącznie pierwiastki jednokrotne, posiadał n pierwiastków rzeczywistych jest to by wartość ciągu Sturma wynosiła n dla $x=-\infty$ oraz 0 dla $x=+\infty$. 

Warto zauwazyć, że dla liczb dostatecznie dużych, co do wartości bezwzględnej, z uwzględnieniem wartości niewłaściwych $+\infty$ oraz $-\infty$ liczba zmian znaków zależy wyłącznie od współczynnika stojącego przy najwyżej potędze wielomianu. Znajduje to potwierdzenie w poniższym twierdzeniu.

\begin{theorem}
	Jeżeli współczynnik stojący przy najwyższej potędze wielomianu jest większy od 0, to wartość tego wielomianu jest większa od zera w punkcie $x=+\infty$ oraz mniejsza od zera w punkcie $x=-\infty$.
	Z kolei, gdy współczynnik stojący przy najwyższej potędze wielomianu jest mniejszy od 0, to wartość tego wielomianu jest mniejsza od zera w punkcie $x=+\infty$ oraz większa od zera w punkcie $x=-\infty$.
\end{theorem}

Na podstawie powyższego twierdzenia można zauważyć, że nie ma potrzeby wyliczania wartości wyrazów ciągu sturma dla wartości niewłaściwych, tzn. $x=-\infty$ oraz $x=+\infty.$ Dzieje się tak dlatego, że wartość wielomianu nie jest ważna, a istotny jest jedynie znak. Fakt ten ma duży wpływ na optymalizacje obliczeń, gdyż dla wielomianów wysokich stopni ograniczamy się jedynie do sprawdzenia znaku przy najwyższej potędze, pomijąc wykonywanie potęgowania, mnożenia i sumowania kolejnych wyrazów wielomianu.
Jeżeli zależy nam, na obliczeniu wartości wielomianu, dla odpowiednio dużych x, będącego ilorazem dwóch wielomianów, możemy skorzystać z poniższego twierdzenia.

\begin{theorem}
	Dany jest wielomian $W_1(x) = a_0x^n + a_1x^{n-1} + a_2x^{n-2} + ... + a_{n-1}x  + a_n,\ gdzie \ a_0 \ne 0$, stopnia n oraz wielomian $W_2(x) = b_0x^{n-1} + b_1x^{n-2} + b_2x^{n-3} + ... + b_{n-2}x  + b_{n-1},\ gdzie\ b_0 \ne 0$, stopnia n-1. Wówczas $\lim_{x \to +\infty}\frac{W_1(x)}{W_2(x)} = \frac{a_0}{b_0}$ oraz $\lim_{x \to -\infty}\frac{W_1(x)}{W_2(x)} = -\frac{a_0}{b_0}.$
\end{theorem}

Jak widać jesteśmy w stanie ustalić znak, a nawet dokładną wartość, największego współczynnika wielomianu, będącego ilorazem dwóch innych wielomianów, wykonując proste dzielenie dwóch liczb, będących odpowiednio najwyższymi współczynnikami wielomianów - dzielnej i dzielnika.


\section{Biblioteka Mpir}

\subsection{Podstawowe informacje}

\subsubsection{Wstęp}

Mpir jest przykładem biblioteki napisanej w języku C, pozwalającą operować na liczby o dowolnej wielkości i dokładności. Jej celem było dostarczenie narzędzia dla arytmetyki na liczbach, które nie są wspierane przez podstawowe typy wbudowane w języku C.

Kluczowy jest fakt, że biblioteka ta została zoptymalizowana w taki sposób, by w zależności od potrzeb używać odmiennych algorytmów. Stało się tak dlatego, że algorytm działania na małych liczbach z niewielką precyzją jest prosty i znacznie różni się od wymyślnej metody, używanej w przypadku wielkich liczb, z setkami cyfr po przecinku.

Warto zauważyć, że optymalizacja kodu odbywa się także w zależności od rodzaju procesora, na którym są wykonywane obliczenia. Biblioteka przeznaczona dla procesorów Intel i7 dostarcza inny kod niż dla procesora Pentium 4 lub Athlon. Dzięki temu, z pewnością, działa w sposób bardziej wydajny, kosztem wygody programistów, którzy jej używają. Nie są oni w łatwy sposób zapewnić optymalnego działania programu, niezależnie od sprzętu na którym jest on uruchamiany, co może znacznie utrudnić proces powstawania nowego oprogramowania, bazującego na bibliotece mpir.

\subsubsection{Licencja}

Biblioteka mpir jest przykładem wolnego oprogramowania, charakteryzującego się kilkoma podstawowymi założeniami. Pierwszą z nich jest wolność pozwalająca użytkownikowi na uruchamianie programu, w dowolnym celu. Drugą jest jego analiza oraz dostosowywania go do swoich potrzeb. Kolejną cechą jest możliwość dowolnego rozpowszechnianie kopii programu. Ostatnią zaś jest udoskonalanie programu i publiczne rozprowadzanie własnych ulepszeń, z których każdy będzie mógł skorzystać.

\subsubsection{Nazewnictwo i typy}

Biblioteka mpir posiada odpowiedniki dla wszystkich podstawowych typów liczbowych, które są charakterystyczne dla języka C. Odpowiednikiem typów całkowitych jest typ mpz\_t, zaś odpowiednikiem liczb zmiennoprzecinkowych, typu float, jest mpq\_t. Dla liczb całkowitych możemy łatwo zdecydować, czy interesuje nas liczba ze znakiem, czy bez niego. Oba przypadki posiadają prawie identycznie nazwane funkcje. Jedyną różnicą jest to, że dla zmiennych ze znakiem występuje przyrostek si, od wyrazu angielskiego wyrazu signed, a dla zmiennych bez znaku przyrostek ui, od wyrazu unsigned. Typ mpq\_t daje użytkownikowi możliwość zdefiniowana dowolnej liczby, dającej się przedstawić w postaci ułamka, czyli dowolnej liczby wymiernej. Ograniczenie to spowodowane jest faktem, iż liczba taka składa się z dwóch liczb typu mpz\_t. Pierwsza z nich jest licznikiem, a druga mianownikiem.

\subsubsection{Funkcje}
W bibliotece przyjęto konwencję charakterystyczną, dla języka C, polegającą na tym, że zarówno argumenty wejściowe jak i wyjściowe funkcji są przekazywane za pomocą referencji do funkcji, która zazwyczaj jest typu void, czyli nie zwraca żadnej wartości. Warto zauważyć, że argumenty wyjściowe są podawane przed wejściowymi. Stało się tak poprzez zachowanie analogii do operatora przypisania, w którym to zmienna wynikowa znajduje się po lewej stronie.
W bibliotece mpir zmienna po zadeklarowaniu nie jest natychmiastowo gotowa do użycia, ponieważ wymaga inicjalizacji, przydzielającej jej miejsce w pamięci. Możemy to zrobić poprzez wywołanie odpowiedniej funkcji init, w argumencie podając odpowiednią zmienną. Analogicznie, aby zwolnić zajmowany, przez zmienną, obszar pamięci należy wywołać funkcję clear. Istnieją także funkcje realokujące, czyli zwiększające lub zmniejszające, zajmowany obszar. Użycie ich jest jednak opcjonalne, gdyż zmiana rozmiaru jest automatycznie wykrywana. Raz zainicjalizowaną zmienną, można używać dowolną liczbę razy. Twórcy biblioteki zalecają unikanie nadmiernego korzystania z funkcji init i clear, ponieważ są to operacje czasochłonne i zbyt duża liczba ich wywołań może mieć negatywny wpływ na wydajność naszego programu.

\subsubsection{Zarządzanie pamięcią}
Biblioteka mpir, alokując w pamięci nowe obiekty, stara się minimalizować wielkość, zajmowaną przez nie, miejsca. Dodatkowa pamięć jest przyznawana dopiero, kiedy jej aktualna wielkość jest niewystarczająca. W przypadku zmiennych typów mpz\_t i mpq\_t, raz zwiększony rozmiar danej zmiennej nigdy nie zostanie zmniejszony. Zazwyczaj jest to najlepsza praktyka, ponieważ częsta alokacja pamięci ma niekorzystny wpływ na wydajność programu. Jeżeli aplikacja potrzebuje zmniejszyć zajmowane przez daną zmienną miejsce, można dokonać realokacji albo całkowicie zwolnić, zajmowane przez nią miejsce. Dodatkowo kolejne zwiększania rozmiaru przeznaczonego na poszczególne zmienne może powodować zauważalny spadek wydajności lub fragmentację danych. Nie da się uniknąć, jeżeli chcemy zaalokować więcej miejsca dla danej zmiennej, w momencie, gdy w jej sąsiedztwie znajdują się już inne zmienne. Wówczas zależnie od implementacji mamy do czynienia z jednej z dwóch wariantów. W pierwszym przypadku, alokujemy nowe miejsce w pamięci, uzupełniając odpowiednio jego wartość, a następnie zwalniając wcześniej zajmowane miejsce. Alternatywą jest pozostawienie zajmowanej już pamięci i przydzielenie dodatkowej w innym miejscu. W takim przypadku jesteśmy zmuszeni do odpowiedniego zarządzania nieciągłymi fragmentami pamięci, co również może mieć bardzo negatywny wpływ na wydajność aplikacji. Z kolei, zmienne typu mpf\_t mają niezmienny rozmiar, zależny od wybranej precyzji. \\
Warto zauważyć, że biblioteka standardowo do alokowania pamięci domyślnie używa funkcji malloc, ale możliwe jest także korzystanie z funkcji alloca. Pierwszy alokator zajmuje się tylko przydzieleniem pamięci, a użytkownik musi sam pamiętać, o jego zwolnieniu, w odpowiednim momencie. Z kolei, drugi z nich zdejmuje tę odpowiedzialność ze strony programisty i sam dba o zwolnienie pamięci, gdy jest ona już nie używana.

\subsubsection{Kompatybilność}
Poza kilkoma wyjątkami, biblioteka mpir jest kompatybilna z odpowiednimi wersjami biblioteki gmp. Dodatkowo, jej twórcy starają się nie usuwać istniejących już funkcji. W przypadku, gdy któraś przestanie być rekomendowana, zostaje po prostu zaznaczona jako przestarzawała, ale jej implementacja nie przestaje istnieć w kolejnych wydaniach biblioteki. Dzięki temu program, bazujący na starszej wersji biblioteki, zadziała też na nowszej edycji.

\subsubsection{Wydajność}
Dla małych liczb, narzut na korzystanie z biblioteki może być znaczący w porównaniu do typów prostych. Jest to nieuniknione, ale celem biblioteki jest próba znalezienia złotego środka pomiędzy wysoką wydajność, zarówno dla małych, jak i dużych liczb. 

\subsubsection{Operacje w miejscu}
Operacje obliczania wartości bezwzględnej i negacji danej liczby są bardzo szybkie, gdy obliczane są w miejscu, tzn. wtedy, gdy zmienna wejściowa jest również zmienną wyjściową. Wówczas nie ma potrzeby alokacji i zwalnia pamięci, a cała funkcja sprowadza się do ustawienia odpowiedniego bitu, mówiącego o znaku liczby. Według specyfikacji biblioteki mpir, zauważalny powinien być także zysk, w przypadku operacji dodawania, odejmowania i mnożenie w miejscu. W momencie, gdy drugim argumentem jest nieduża liczba całkowite operację te są nieskomplikowane i bardzo szybkie.

\subsection{Instalacja}

Instalacja biblioteki mpir jest różna w zależności od systemu operacyjnego. W systemach unixowych instalacja polega na zbudowaniu i instalacji, korzystając ze źródeł. Pod windowsem jest ona równie łatwa i przebiega analogicznie, o ile używamy cygwina lub mingw. Są to narzędzia, które zapewniają, programom działającym pod systemem Windows, funkcjonalność przypominającą system Linux. Bardziej skomplikowane będzie użycie biblioteki bez wyżej wymienionych narzędzi, ale warto zaznaczyć, że biblioteka ta może być budowana z użyciem Microsoft Visual Studio, począwszy od wersji 2010, korzystając z programu o nazwie yasm asembler. Dodatkowo korzystanie z biblioteki różni się w zależności od tego czy potrzebujemy jej statyczną (mpir/lib) czy dynamiczną (mpir/dll) wersję.

Aby używać biblioteki mpir w naszym programie musimy do naszego programu dodać następującą linię:
\begin{lstlisting}
#include <mpir.h>
\end{lstlisting}
Pozwoli ona nam na używanie wszystkich funkcji i typów, które udostępnia dla nas biblioteka. Dodatkowo wymagana jest kompilacja z dołączeniem naszej biblioteki, poprzez dodanie opcji -lmpir, np.:
\begin{lstlisting}
gcc myprogram.c -lmpir
\end{lstlisting}
Jeżeli chcemy skorzystać z biblioteki, wspierającej język C++ dodatkowo musimy dodać także opcję -mpirxx, np.:
\begin{lstlisting}
g++ myprogram.cc -lmpirxx -lmpir
\end{lstlisting}

\subsection{Operacje na liczbach całkowitych}
W niniejszym podrozdziale, omówię podstawowe funkcje liczbowe, które mają zastosowanie, zarówno dla liczb całkowitych typu mpz\_t, jak i rzeczywistych typu mpq\_t.

\subsubsection{Funkcje inicjalizujące}
\begin{lstlisting}
void mpz_init (mpz_t integer)
\end{lstlisting}
Alokuje w pamięci miejsce na zmienną integer i ustawia jej wartość na 0.

\begin{lstlisting}
void mpz_clear (mpz_t integer)
\end{lstlisting}
Zwalnia miejsce zajmowaną przez zmienną. Funkcja ta powinna być używana dla każdej zmiennej, w momencie, gdy nie ma już potrzeby, by z niej korzystać.

\begin{lstlisting}
void mpz_realloc2 (mpz_t integer, mp bitcnt_t n)
\end{lstlisting}
Zmienia rozmiar zajmowanego przez zmienną miejsca. Funkcja jest używana z wartością n, większą od aktualnej, by zagwarantować zmiennej określone miejsce w pamięci. Z drugiej strony, zostaje wywołana z wartością mniejszą, jeżeli chcemy zmniejszyć liczbę zajmowanego przez zmienną miejsca. Gdy nowy rozmiar jest wystarczający by pomieścić aktualną wartość zmiennej, to zostaje ona zachowana. W przeciwnym razie zostanie ona ustawiona na 0. Istnieje również przestarzała funkcja mpz\_realloc, ale jej użycie jest niezalecane. Nie została usunięta, by zachować kompatybilność wsteczną.

\subsubsection{Funkcje przypisania}

\begin{lstlisting}
void mpz_set (mpz_t rop, mpz_t op)
\end{lstlisting}
Pozwala na przypisanie wartości tych samów typów. Wartość zmiennej op jest ustawiana jako rop. Jest to równoważnik operatora przypisania.

\begin{lstlisting}
void mpz_set_sx (mpz_t rop, intmax_t op)
\end{lstlisting}
Pozwala na przypisanie zmiennej typu całkowitego do wartości typu mpz\_t.

\begin{lstlisting}
void mpz_set_d (mpz_t rop, double op)
\end{lstlisting}
Zapisuje wqrtość typu double do zmiennej typu mpz\_t.

\begin{lstlisting}
void mpz_set_q (mpz_t rop, mpq_t op)
\end{lstlisting}
Pozwala na zrzutowanie liczby rzeczywistej, typu mpq\_t do zmiennej mpz\_t. Gdy liczba mpq\_t nie jest liczbą całkowitą, zostaje ona zaokrąglona w dół, poprzez obcięcie jej części ułamkowej.

\begin{lstlisting}
int mpz_set_str (mpz_t rop, char *str, int base)
\end{lstlisting}
Konstruuje liczbę typu mpz\_t, na podstawie podanego łańcucha znaków, reprezentującego daną liczbę. Wartość zmiennej base mówi o podstawie podanej liczby. Zmienna znakowa dopuszcza występowanie białych znaków, które są ignorowane. Z kolei zmienna base dopuszcza 0 oraz wartości z zakresu (2,61). Gdy jest ona równa 0, podstawowa zostaje ustalona, bazując na początkowych znakach. Dla prefixów 0x oraz 0X reprezentacja liczby zostaje ustalona jako szesnastkowa. Gdy jest ona równa 0b lub 0X to liczba ta jest binarna, a gdy rozpoczyna się od zera, a drugi znak jest inny od wymienionych, to zostaje uznana za liczbę oktalną. W pozostałych wypadkach jest to liczba dziesiętna. Kolejne wartości dziesiętne od 10 do 35 są reprezentowane jako litery od a do z, przy czym nie ma rozróżnienia ze względu na wielkość liter. W przypadku wyższych wartości podstawy, wielkość liter ma znaczenia, przy czym liczby od 10 do 35 reprezentowane są przez duże litery, a liczby od 36 do 61 przez litery małe. Funkcja dokonuje weryfikacji, czy podane ciąg znaków w całości reprezentuje poprawną wartość liczbą. Jeżeli tak, to zwraca ona wartość 0. W przeciwnym wypadku jest to wartość 1.

\begin{lstlisting}
void mpz_swap (mpz_t rop1, mpz_t rop2)
\end{lstlisting}
Używana jest do zamiany wartości pomiędzy dwoma zmiennymi typu mpz\_t. Jej użycie jest rekomendowane, ze względów wydajnościowych. W przypadku braku tej funkcji, potrzeba by zmiennej tymczasowej. W tym celu musiała by ona na początku zostać zaalokowana w pamięci, a na końcu zwolniona. Obie operacje są czasochłonne i zaleca się minimalizować ich użycie, więc użycie zoptymalizowanej funkcji służącej do zamiany wartości dużych liczb wydaje się zdecydowanie najlepszą i najszybszą opcją.

\subsubsection{Funkcje konwersji}

\begin{lstlisting}
intmax_t mpz_get_sx (mpz_t op)
\end{lstlisting}
Zwraca zmienną typu int, a znak liczby zostaje przepisany. Jeżeli wartość jest poza zakresem liczb typu int, to rzutowanie następuje poprzez pozostawienie najmniej znaczącej części. Powoduje to, że funkcja w wielu przypadkach może okazać się bezużyteczna.

\begin{lstlisting}
double mpz_get_d (mpz_t op)
\end{lstlisting}
Pozwala zrzutować typ mpz\_t na zmienną typu double. Jeżeli jest to konieczne, stosowane jest zaokrąglenie. Jeżeli eksponent jest za duży, zwrócony wynik jest zależny od danego systemu. Jeżeli jest dostępna, zwrócona może być wartość nieskończoności.

\begin{lstlisting}
char * mpz_get_str (char *str, int base, mpz_t op)
\end{lstlisting}
Zwraca ciąg znaków reprezentujących liczbę op., o podstawie danej w paremetrze o nazwie base. Funkcja ta jest analogiczna do mpz\_set\_str. Jeżeli parametrem str jest NULL, to ciąg znaków zostaje zwrócony przez funkcję. W przeciwnym razie funkcja umieszcza go pod adresem, na który wskazuje zmienna str. Należy zadbać o to, by bufor, do zapisania rezultatu funkcji, był wystarczający. Powinien on być 2 bajty dłuższy niż długość zwróconej liczby w danym systemie liczbowym. Pierwszy bajt to służy na wpisanie ewentualnego znaków minus, natomiast drugi na znak ‘\\0’ kończący łańcuch znaków. Długość zasadniczej części liczbowej można pobrać używając funkcji mpz\_sizeinbase (op, base), w której podajemy odpowiednio daną liczbę oraz podstawę.

\subsubsection{Funkcje arytmetyczne}

\begin{lstlisting}
void mpz_add (mpz_t rop, mpz_t op1, mpz_t op2)
\end{lstlisting}
Ustawia wartość rop jako sumę op1 i op2.

\begin{lstlisting}
void mpz_sub (mpz_t rop, mpz_t op1, mpz_t op2)
\end{lstlisting}
Ustawia wartość rop jako różnicę op1 i op2.

\begin{lstlisting}
void mpz_mul (mpz_t rop, mpz_t op1, mpz_t op2)
\end{lstlisting}
Ustawia wartość rop jako iloczyn op1 i op2.

\begin{lstlisting}
void mpz_addmul (mpz_t rop, mpz_t op1, mpz_t op2)
\end{lstlisting}
Oblicza wartość iloczynu czynników op1 i op2, a następnie zwiększa wartość rop o otrzymany wynik. Tożsame z wykonaniem działania rop = rop + op1*op2.

\begin{lstlisting}
void mpz_submul (mpz_t rop, mpz_t op1, mpz_t op2)
\end{lstlisting}
Oblicza wartość iloczynu czynników op1 i op2, a następnie zmniejsza wartość rop o otrzymany wynik. Tożsame z wykonaniem działania rop = rop - op1*op2.

\begin{lstlisting}
void mpz_neg (mpz_t rop, mpz_t op)
\end{lstlisting}
Jako rezultat ustawia liczbę przeciwną do danej. Gdy rop i op są tą samą zmienną to mamy do czynienia z przykładem operacji w miejscu. Wówczas całe funkcja jest bardzo szybka, gdyż opiera się tylko na zmianie bitu, mówiącym o znaku danej liczby.

\begin{lstlisting}
void mpz_abs (mpz_t rop, mpz_t op)
\end{lstlisting}
Funkcja w swoim działaniu bardzo podobna do funkcji mpz\_neg. Jedyną róznicą jest to, że bit znaku nie zostaje zanegowany, a ustawiony tak, by wskazywał na wartość nieujemną.

\subsubsection{Funkcje dzielenia}
Uzywając niżej wymienionych funkcji należy pamiętać, ze dzielenie przez 0, zarówno w przypadku obliczania wartości ilorazu, jak i reszty z dzielenia jest nielegalne. W przypadku, gdy wystąpi taka sytuacja, biblioteka zachowa się jak w przypadku dzielenia przez 0, dla liczb typu int, tzn. skończy działanie funkcji, rzucając odpowiedni wyjątek.

\begin{lstlisting}
void mpz_tdiv_q (mpz_t q, mpz_t n, mpz_t d)
\end{lstlisting}
Funkcja oblicza iloraz z liczb n i d. Litera przed ‘div’ w nazwie funkcji mówi, o jej zachowaniu w przypadku, gdy rezultat nie jest liczbą całkowitą. Symbol ‘t’ (truncate), oznacza obcięcie części ułamkowej. Zalecanym użyciem jest przypadek, gdy nie ma znaczenia wartość reszty z dzielenia.

\begin{lstlisting}
void mpz_tdiv_r (mpz_t r, mpz_t n, mpz_t d)
\end{lstlisting}
Oblicza wartość rezsty z dzielenia liczb n i d. Podobnie jak w fukcji mpz\_tdiv\_q, mamy do czynienia z przypadkiem obcięcia ewentualnej części ułamkowej ilorazu. Oznacza to, że zwracana reszta zawsze będzie tego samego znaku co zmienna n. Rekomendowana, gdy wartość ilorazu z dzielenia nie jest istotna.

\begin{lstlisting}
void mpz_tdiv_qr (mpz_t q, mpz_t r, mpz_t n, mpz_t d)
\end{lstlisting}

Łączy w sumie dwie powyższe funkcje. Ze względów wygody i wydajności zaleca się jej użycie wówczas, gdy potrzebujemy obliczyć zarówno iloraz, jak i resztę z dzielenia. Ważne jest by pamiętać, że przekazane argumenty q i r, muszą być referencjami do różnych zmiennych. W przeciwnym razie, działanie funkcji będzie nie poprawne, a wynik najprawdopodobniej błędny.

Oprócz wyżej wymienionych funkcji, istnieją także ich odpowiedniki, o odmiennym zachowaniu w kwestii zaokrąglania części ułamkowej ilorazu. Pierwszym z nich jest grupa funkcji, posiadająca w nazwie „cdiv”, gdzie litera ‘c’ (ceil) oznacza sufit. Oznacza to, że w razie potrzeby iloraz zostanie zaokrąglony w górę. Wówczas otrzymana reszta r będzie przeciwnego znaku do liczby d. Funkcjami z tej grupy są: mpz\_cdiv\_q, mpz\_cdiv\_r oraz mpz\_cdiv\_qr. Drugim odpowiednik jest grupa funkcji, posiadająca w nazwie „fdiv”, gdzie ‘f’ (floor) oznacza podłogę. Oznacza to, że w razie potrzeby wynik zostanie zaokrąglony w dół. Reszta r będzie w tym przypadku tego samegu znaku co liczba d. Przykładami funkcji z tej grupy są:  mpz\_fdiv\_q, mpz\_fdiv\_r oraz mpz\_fdiv\_qr. Zauważmy, że we wszystkich trzech przypadkach zostaje spełnione równanie n = q * d + r, gdzie 0 <= |r| < |d|.

\begin{lstlisting}
int mpz_divisible_p (mpz_t n, mpz_t d)
\end{lstlisting}
Funkcja sprawdza, czy d dzieli liczbę n. Jeżeli nie, to zwracana 0, w przeciwnym razie zwraca wartość różną od zera.

\begin{lstlisting}
void mpz_divexact (mpz_t q, mpz_t n, mpz_t d)
\end{lstlisting}
Oblicza iloraz z dzielenia liczb n przez d. Działa poprawnie tylko w przypadku, gdy n jest podzielna przez d. By to sprawdzić można uzyć funkcji mpz\_divisable\_p. Jest znacznie szybsza niż pozostałe funkcje, umożliwiające obliczanie ilorazu z dzielenia. Dlatego zawsze, gdy spełniony jest powyższy warunek,  użycie tej funkcji jest wysoko rekomendowane.

\subsubsection{Funkcje porównania}

\begin{lstlisting}
int mpz_cmp (mpz_t op1, mpz_t op2)
\end{lstlisting}
Porównuje wartości dwóch liczb. Zwraca wartość dodatnią, gdy op1 > op2, ujemną, gdy op1 < op2, oraz 0, gdy obie wartości są równe.

\begin{lstlisting}
int mpz_cmpabs (mpz_t op1, mpz_t op2)
\end{lstlisting}
Porównuje wartość bezwzględną dwóch liczb. Zwraca wartość dodatnią, gdy |op1| > |op2|, ujemną, gdy |op1| < |op2|, oraz 0, gdy obie wartości są równe lub przeciwne.

\begin{lstlisting}
int mpz_sgn (mpz_t op)
\end{lstlisting}
Określa znak danej liczby. Zwraca 1 dla wartości dodatnich, -1 dla wartości ujemnych oraz 0 w przypadku zera. Należy pamiętać, ze w obecnej implementacji mpz\_sgn jest makrem i rozpatruje dany argument wielokrotnie.

\subsubsection{Pozostałe funkcje}

\begin{lstlisting}
void mpz_pow_ui (mpz_t rop, mpz_t base, mpir_ui exp)
\end{lstlisting}
Podnosi liczbę base do potęgi exp.

\begin{lstlisting}
void mpz_sqrt (mpz_t rop, mpz_t op)
\end{lstlisting}
Oblicza pierwiastek całkowity dla danej liczby. W przypadku, gdy wynik nie jest liczbą całkowitą, część ułamkowa zostaje obcięta.

\begin{lstlisting}
void mpz_sqrtrem (mpz_t rop1, mpz_t rop2, mpz_t op)
\end{lstlisting}
Jest bardzo podobna do funkcji mpz\_sqrt. Poza obliczeniem wartości pierwiastka z danej liczby, zwraca także różnicę pomiędzy daną liczbą a kwadratem tego pierwiastka.
Rop1 = sqrt(op)
Rop2 = op – sqrt(rop1)\^2.
Zauważmy, że jeżeli rop2 = 0, to rop1 jest pierwiastkiem kwadratotowym z op.

\subsubsection{Operacje na liczbach rzeczywistych}
W tym podrozdziale, rozpatrzę funkcje dla zmiennych typu mpq\_t. Skupię się w nim na funkcjach, które nie występują dla liczb całkowitych typu mpz\_t, opisanych w poprzednim podrozdziale lub ich implementacja znacząco się różni, od już przedstawionej.
Na początku warto zaznaczyć, że zmienne mpq\_t reprezentują wyłącznie liczby wymierne. Jest to spowodowane ich implementacją. Każda liczba typu mpq\_t składa się z dwóch liczb całkowitych typu mpz\_t, reprezentujących licznik i mianownik.

\begin{lstlisting}
void mpq_init (mpq_t dest_rational)
\end{lstlisting}
Funkcja alokuje miejsce w pamięci i inicjuje wartość danej liczby, ustawiając licznik na 0 i mianownik na 1.

\begin{lstlisting}
void mpq_canonicalize (mpq_t op)
\end{lstlisting}
Znajduje wspólne dzielniki licznika i mianownika, skracając ułamek. Dodatkowo zapewnia, że mianownik jest liczbą dodatnią, w razie potrzeby, mnożąc licznik i mianownik przez liczbę -1.

\begin{lstlisting}
int mpq_set_str (mpq_t rop, char *str, int base)
\end{lstlisting}
Tworzy liczbę na podstawie wartości podanej w łańcuchu znaków. Jej wartość podawana jest w postaci najpierw licznik, a następnie mianownik, na zasadach podobnym jak w funkcji mpz\_set\_str. Obie liczby oddziela znak operatora dzielenia ‘/’. Funkcja zwraca wartość 0 w przypadku gdy cały łańcuch wejściowy jest poprawny oraz -1 w innym przypadku. Jeżeli argument base jest równy 0, to format liczbowy, dla licznika i mianownika, jest ustalany osobno. Oznacza to, że możemy podać liczby w dwóch różnych formatach, np. „0xFF/256” . Warto zauważyć, że funkcja mpq\_canonicalize nie jest wołana automatycznie, więc jeżeli podaliśmy ułamek, który chcemy skrócić, to musimy pamiętać o jej wywołaniu.

\begin{lstlisting}
char * mpq_get_str (char *str, int base, mpq_t op)
\end{lstlisting}
Funkcja zwracająca liczbę w postaci ułamka, tzn. licznik i mianownik, oddzielony znakiem kreski ułamkowej. Jest analogiczna do funkcji mpz\_get\_str. Bufor wyjściowy, w którym chcemy umieścić rezultat funkcji powinien być, wystarczający i wynosić mpz\_sizeinbase(mpq\_numref(op), base) + mpz\_sizeinbase (mpq\_denref(op), base) + 3. Jeden dodatkowy bajt w porównaniu do funkcji mpz\_get\_str, spowodowany jest koniecznością umieszczenia w buforze kreski ułamkowej.


.\\
.\\

\chapter{Opis Rozwiązania}
\section{Podział na moduły}
\section{Główne klasy}
\section{Główne funkcje}
Parser
Klasa umożliwiająca użytkownikom podanie wielomianów poprzez standardowe wejście. Składa się tylko z dwóch metod.
Zadaniem pierwszej z nich jest unifikacja wielomianu podanego na wejściu. Funkcja jako argument przyjmuje pojedynczy obiekt klasy string. Po dokonaniu odpowiednich operacji, jako rezultat funkcji, zwraca również typ string. Użycie funkcji ma na celu ułatwienie przetwarzania w kolejnym etapie, w którym na podstawie podanego ciągu znaków, tworzony będzie obiekt wielomianu. Głównym zadaniem funkcji, jest weryfikacja, czy ciąg znaków podanych na wejściu reprezentuje poprawny składniowo wielomian. Weryfikowana jest liczba nawias otwierających i zamykających oraz fakt, czy w każdym miejscu wyrażenia liczba otwartych nawiasów jest nie mniejsza niż liczba nawiasów zamkniętych. Dodatkowo sprawdzane jest, 
czy na sąsiednich miejscach nie występują dwa operatory. Dodatkowo poprawne wyrażenie nigdy nie kończy się operatorem, a zaczynać może się tylko minusem, literałem, cyfrą lub nawiasem otwierającym. W czasie unifikacji wyrażenia, ignorowane są wszystkie występujące w nim białe znaki. Warto zaznaczyć, że dopuszczalny jest tylko jeden znak, reprezentujący zmienną wielomianu. Nie ma ograniczeń co do wartości tego znaku, może być to znak ‘a’, ‘x’, lub jakikolwiek chcemy, ale powinniśmy zadbać, by w całym wyrażeniu występował on w tej samej postaci. Sporym ułatwieniem w interfejsie jest brak konieczności 
wpisywania operatorów mnożenia (*) i potęgowania (\^) w oczywistych miejscach. Z punktu widzenia aplikacji wyrażenia 4x oraz 4*x są identyczne. Podobnie jest w przypadku x3 oraz x\^3. Funkcja
przeanalizuje wyrażenie i zwróci je w odpowiedniej postaci. Dla przykładu wyrażenia x3+2x2+3x+1, x\^3 +2x\^2 + 3x+1 zostaną zamienione w x\^3+2*x\^2+3*x+1.
\section{Zewnętrze biblioteki}
\section{Instrukcja programu}

\chapter{Przeprowadzone testy}
\section{Testy jednostkowe}
\section{Testy interfejsu użytkownika}
\section{Testy wydajności czasowej}
\section{Testy wydajności pamięciowej}
\chapter{Podsumowanie}


\backmatter


% rodzaj bibliografii
\bibliographystyle{plain}
% plik z wpisami bibliograficznymi
\nocite{barbeau2003polynomials}
\nocite{buell2004algorithmic}
\nocite{burden2015numerical}
\nocite{childs2012concrete}
\nocite{granlund2015gnu}
\nocite{kryszewski2014wyklad}
\nocite{malik2009data}
\nocite{mcnamee2007numerical}
\nocite{mora2003solving}
\nocite{pan2012structured}
\nocite{polskie1968wiadomosci}
\nocite{sierpinski1951zasady}
\nocite{Warmus_Mieczyslaw_(1918-2007)_Metody}
\bibliography{bibliografia}



\end{document}