\chapter{Opis rozwiązania}
\section{Podział na moduły}

Aplikacja została podzielona na trzy główne moduły: statyczna biblioteka, aplikacja konsolowa oraz testy jednostkowe. Każdy z nich został zawarty w osobnym projekcie, stworzonym w programie Microsoft Visual Studio 2015. Moduły te zostały ze sobą odpowiednio powiązane, razem tworząc solucję. Pomiędzy modułami występują jasno określone zależności. Aplikacja konsolowa i projekt testowy są od siebie całkowicie niezależne, więc zmiany i błędy w jednym z nich, nie mają wpływu na drugi. Obie te części zależą od biblioteki statycznej, bezpośrednio się do niej odwołując. Aplikacja konsolowa udostępnia interfejs użytkownika do wspomnianej funkcjonalności, a framework testowy weryfikuje jej poprawność. Dodatkowo oba projekty są zależne od biblioteki mpir, która musi być dołączana w sposób dynamiczny, poprzez dodanie odpowiedniego pliku typu dll. 

\subsection{Statyczna biblioteka}

Statyczna biblioteka zawiera wszystkie logiczne aspekty projektu, posiada odpowiednie klasy, zdefiniowane funkcje i zaimplementowane algorytmy, gotowe do wykorzystania i przetestowania. To w tej częsci projektu są zaprojektowane klasy pomocniczne -- CharsConstants i StringManager oraz klasa Number, pozwalająca na łatwe korzystanie z dużych liczb wymiernych. Ta ostatnia jest warstwą pośrednią pomiędzy biblioteką mpir, a pozostałymi częściami projektu. Klasa ta, jako jedyna zależy w bezpośredni sposób od implementacji wspomnianej biblioteki. Innymi słowy, nawet w przypadku bardzo radykalnych zmian w bibliotece mpir, jest to jedyna klasa, wymagająca zmiany. Jest to bardzo wygodny i bezpieczny sposób na całkowite uniezależnienie pozostałej części od implementacji innego projektu, na którego kierunek rozwoju programista nie ma wpływu.

Moduł zawiera także najważniejszą część projektu, czyli klasy umożliwiające wykonanie działań na wielomianach. Istnieją dwie takie klasy -- PolynomialMap i PolynomialVector, używajace odpowiednio mapy i tablicy, do przetrzymywania struktury wielomianów. Dla obu takich klas została zdefiniowana klasa abstraktycjna Polynomial, która implementuje wspólne funkcja, a także definiuje interfejs dla klas pochodnych. Działanie obu klas jest analogiczne, ale zostało zaimplementowane w odmienny sposób, co ma zasadniczny wpływ na wydajność rozwiązania, dla konkretnych typów wielomianów.

Część ta jest zależna od odpowiednio skompilowanej biblioteki mpir. W przeciwieństwie do aplikacji konsolowej i frameworku testowego, wystarczająca jest jej statycznie dołączana wersja. Warto zaznaczyć, że wersja ta jest inna dla różnych komputerów. Jest ona zależna od rodzaju procesora, ponieważ jej kod asemblerowy został zoptymalizowany, pod jego konkretny typ. Może to powodować różnice w wydajności biblioteki, ale nie powinno mieć żadnego wpływu na jej deterministyczne zachowanie. Dlatego jej działanie zawsze powinno być przewidywalne i takie samo, niezależne od rodzaju platformy, na której jest używana.

\subsection{Aplikacja konsolowa}

Aplikacja konsolowa pozwala, w łatwy dla użytkownika sposób, na tworzenie wielomianów i obliczanie wartości ich pierwiastków w zadanym przedziale. Użytkownik podaje odpowiednie dane wejściowe z linii poleceń, a te są następnie przetwarzane. Otrzymane wyniki są wypisywane na standardowe wyjście w przystępny sposób, tzn. w systemie dziesiętnym i z określoną precyzją.

Warto zaznaczyć, że użytkownik może wprowadzać wielomiany w dowolny sposób. Mogą być one zarówno w postaci sumy kolejnych współczynników, jak i skomplikowanych iloczynów, składających się z poszczególnych wielomianów. Jedynym ograniczeniem jest to, by wyrażenie było poprawne składniowo oraz zawierało wyłącznie całkowite współczyniki i naturalne potęgi. Nie powinno być to jednak przeszkodą w obliczaniu pierwiastków dla skomplikowanych wielomianów. Należy bowiem pamiętać, że kazdy wielomian o współczynnikach wymiernych, a tylko takie będziemy rozwazać w niniejszej pracy, da się przedstawić przy pomocy proporcjonalnych liczb całkowitych. Odpowiednie ułamki zwykłe, zawsze możemy w ten sposób zamienić, wyciągając z danego wielomianu czynnik, będący odwrotnością najmniejszej wspólnej wielokrotności, wszystkich współczynników. Jako, że czynnik ten będzie stałą, to przy obliczaniu pierwiastków, można go po prostu pominąć, gdyż nie ma on na nie żadnego wpływu.

Użytkownik może korzystać z aplikacji tak długo, jak będzie sobie tego życzył. Zapytanie o kolejne wielomiany przeprowadzonę są w pętli i trwają, dopóki użytkownik nie wprowadzi ciągu znaków, odpowiedzialnego za wyjście z programu. Szczegółowe informację, o tym jak korzystać z aplikacji są podane w jego instrukcji.

\subsection{Framework testowy}
Testy jednostkowe umożliwiają użytkownikowi sprawdzenie, czy określona funkcjonalność działa bezbłędnie. Zgodnie z ich założeniami, są w nich zdefiniowe podstawowe testy, weryfikujące różne przypadki testowe. W tym przypadku jest nieco inaczej, ponieważ w postaci testów jednostkowych, zostały zawarte również bardziej skomplikowane testy funkcjonalne. Wśród nich znajdują się też takie, które testują główne zadanie projektu, czyli dla wielomianu, tworzonego na podstawie otrzymanego wejścia, w postaci łańcucha znaków, potrafią, z określoną precyzją, znaleźć jego wszystkie pierwiastki rzeczywiste.

Jako środowisko testowe wybrany został framework wbudowany w narzędzie Microsoft Visual Studio 2015. Rozważana była też biblioteka o nazwie Google Test. Jej istotną zaletą, była przenośność, ale ostatecznie koncepcja ta została odrzucona. Spowodowane było to faktem, iż cały projekt pisany był w Visual Studio, a łatwość i wygoda, uruchamiania w nim testów jednostkowych jest bardzo duża. Dzięki temu wyborowi każda, nawet najmniejsza zmiana, mogła być bardzo szybka przetestowana, bez potrzeby wprowadzania jakichkolwiek dodatkowych zmian, co znacznie przyspieszało proces implementacji i weryfikacji przyjętego rozwiązania.